---
title: "QSRR revisited. Hierarchical models"
author:
  - name: "Paweł Wiczling*"
    affiliations:
      - name: "Department of Biopharmaceutics and Pharmacodynamics, Medical University of Gdańsk, Gen. J. Hallera 107, 80-416 Gdańsk, Poland"
date: "`r format(Sys.Date())`"
format:
  html:
    theme: cosmo
    toc: true
    code-fold: true  
    code-tools: true
    fig-width: 7
    fig-height: 7
knitr:
  opts_chunk: 
    dev: "ragg_png"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=FALSE, message=FALSE, error=FALSE, warning=FALSE, comment=NA, out.width='95%')
```

# Introductions

...

# Setup
```{r message=FALSE}
library(cmdstanr)
library(ggplot2)
library(gridExtra)
library(patchwork)
library(rstan)
library(tidyr)
library(dplyr)
library(posterior)
library(bayesplot)
library(GGally)
library(reshape2)
library(pracma)
library(brms)
library(here)
library(magick)
library(ggcorrplot)
#remotes::install_github("metrumresearchgroup/mrgmisc")
set_cmdstan_path("C:/Users/GUMed/.cmdstan/cmdstan-2.36.0")
set.seed(10271998) ## not required but assures repeatable results

source("helper-functions.R")
```

```{r settings}
data_deliv_dir = here::here("data","deliv")
data_derived_dir = here::here("data","derived")
if(!file.exists(data_deliv_dir)) dir.create(data_deliv_dir, recursive = T)
if(!file.exists(data_derived_dir)) dir.create(data_derived_dir, recursive = T)

figures_eda_dir <- here::here("deliv","figures", "eda")
tables_eda_dir <- here::here("deliv","tables", "eda")
if(!file.exists(figures_eda_dir)) dir.create(figures_eda_dir, recursive = T)
if(!file.exists(tables_eda_dir)) dir.create(tables_eda_dir, recursive = T)

model_dir <- here::here("model","stan")  
figures_dir <- here::here("deliv","figures", "stan")
tables_dir <- here::here("deliv","tables", "stan")
if(!file.exists(figures_dir)) dir.create(figures_dir, recursive = T)
if(!file.exists(model_dir)) dir.create(model_dir, recursive = T)
if(!file.exists(tables_dir)) dir.create(tables_dir, recursive = T)
```

# EDA

We used a publicly available [dataset](www.retentionprediction.org/hplc/database/) that comprises the measurements of RP-HPLC retention times collected for 1026 analytes. The retention times were measured under isocratic conditions on Eclipse Plus C18 (Agilent) stationary phase with 3.5 μm particles. The experiments were conducted using a mixture of two solvents: solvent A, which was made of 0.1% formic acid in water, and solvent B, which was made of 0.1% formic acid in acetonitrile. The column temperature was set at 35\^{\circ}C. The data were collected by Boswell et al. and were used to create a method to predict retention time by Back-Calculating the Gradient.

## Load data
```{r load-data, message=FALSE, warning=FALSE}
# load data
data <- read.csv(here(data_deliv_dir, "database_logk_1026.csv"), header = TRUE)
analytes_names  <- read.csv(here(data_deliv_dir,"database_logk_1026_analyte_names.csv"), header = TRUE)
smiles <- read.csv(here(data_deliv_dir,"smiles1026.smi"), sep = "\t", header = FALSE)
functional_groups = read.csv(here(data_deliv_dir, 'checkmol_functional_groups.csv'))
functional_groups_names = read.csv(here(data_deliv_dir,'checkmol_functional_group_names.csv'))
data_ACD = read.csv(here(data_deliv_dir,'ACD_pKas.csv'))
data_pH <- read.csv(here(data_deliv_dir,"pH.csv"),header = TRUE)
lower_tri_df <-read.csv(here(data_deliv_dir,"similarity_ltri_rcdk.csv"))
similarity_matrix <- make_similarity_matrix_fun(lower_tri_df)
smiles<-smiles %>% rename(ID=V2,smiles=V1) %>% select(ID,smiles)
```

## Prepare data
```{r prepare-data, message=FALSE, warning=FALSE}
data<-data %>%
  left_join(analytes_names) %>%
  mutate(mm_group =case_when(
             MW_ACD < 200 ~ "MM < 200",
             MW_ACD < 300 & MW_ACD >= 200 ~ "200 \u2264 MM < 300",
             MW_ACD < 400 & MW_ACD >= 300 ~ "300 \u2264 MM < 400",
             .default = "400 \u2264 MM"))

# combine nr of caroboxylic acid and carboxyalic acid salt functional groups
# heterocyclic compounds with more than 6 heterocycles are treated as if they have six
functional_groups[,76]=functional_groups[,76]+functional_groups[,77]       
functional_groups[which(functional_groups[,202]>5.5),202] = 6; 

# exclude some functional groups
idx_excluded <- c(1, 2, 3, 6, 27, 28, 37, 47, 48, 51, 55, 61, 62, 67, 73, 74, 75, 77, 80, 91, 99, 109, 116, 117, 121, 125, 129, 142, 153, 154, 160, 161, 168, 173, 178, 181, 182, 186, 187, 191, 196, 201, 202)

functional_groups_names <- functional_groups_names[-idx_excluded,]
functional_groups <- functional_groups[,-idx_excluded]

rm(idx_included)

totalnrgroups <- summarise_each(functional_groups, funs(sum))

# remove functional groups not present in the dataset:
functional_groups <- functional_groups[,which(totalnrgroups!=0)]
functional_groups_names<- functional_groups_names[which(totalnrgroups!=0),]
totalnrgroups <- summarise_each(functional_groups, funs(sum))

pKaslit = data_ACD[,3:5]           # pKa values as predicted by ACD
pKasliterror = data_ACD[,17:19]    # pKa error as predicted by ACD
chargesA = abs(data_ACD[,9:12])    # number of ionized groups (anions)
chargesB = abs(data_ACD[,13:16])   # number of ionized groups (cations)
charges = chargesA+chargesB                       # absolute charge
groupsA = (chargesA[,2:4]-chargesA[,1:3])         # acidic group
groupsB = -(chargesB[,2:4]-chargesB[,1:3])        # basic group
R = rowSums(data_ACD[,3:5]<14) # number of dissociation steps
groups = groupsB-groupsA
logPobs =data %>% distinct(ID, .keep_all = TRUE) %>% pull(logP_ACD)
MW =data %>% distinct(ID, .keep_all = TRUE) %>% pull(MW_ACD)
logPobs[526] = mean(logPobs, na.rm = TRUE)

# identify acidic groups
idxGroupsA <-which(groupsA!=0,arr.ind = T)
nGroupsA <- nrow(idxGroupsA)
pKaslitA<-pKaslit[idxGroupsA]

# identify basic groups
idxGroupsB <-which(groupsB!=0,arr.ind = T)
nGroupsB <- nrow(idxGroupsB)
pKaslitB<-pKaslit[idxGroupsB]

# groups dissociated in the whole pH range
chargesA0 <- chargesA[,1]
chargesB0 <- chargesB[,max(R)]

idxA0 = c(which(chargesA0==1), which(chargesA0==2))
idxB0 = c(which(chargesB0==1), which(chargesB0==2))

nA0 <- length(idxA0)
nB0 <- length(idxB0)

nObs <- length(data$ID)
nAnalytes <- length(unique(data$ID))

start <- (1:nObs)[!duplicated(data$ID)]
end <- c(start[-1] - 1, nObs)
```

# Some plots

During the exploratory data analysis phase, we create a series of plots to better understand our data.

```{r similarity-matrixplot}

ggcorrplot((similarity_matrix[001:100,001:100]-0.5)*2)
 ggcorrplot((similarity_matrix[101:200,101:200]-0.5)*2)
 ggcorrplot((similarity_matrix[201:300,201:300]-0.5)*2)
 ggcorrplot((similarity_matrix[301:400,301:400]-0.5)*2)
 ggcorrplot((similarity_matrix[401:500,401:500]-0.5)*2)
 ggcorrplot((similarity_matrix[501:600,501:600]-0.5)*2)
 ggcorrplot((similarity_matrix[601:700,601:700]-0.5)*2)
 ggcorrplot((similarity_matrix[701:800,701:800]-0.5)*2)
 ggcorrplot((similarity_matrix[801:900,801:900]-0.5)*2)
 ggcorrplot((similarity_matrix[901:1026,901:1026]-0.5)*2)

# x=which(similarity_matrix>0.95 & similarity_matrix!=1, arr.ind = TRUE)
# pair_names = cbind(analytes_names$Analyte[unname(x[,1])],analytes_names$Analyte[unname(x[,2])])
# selected_compounds = unique(c(x))
# ggcorrplot((similarity_matrix[selected_compounds,selected_compounds]-0.5)*2)
```

```{r clusterring}
x<-hclust(as.dist(1-similarity_matrix), method = "complete", members = NULL)
plot(x)
cut_avg <- cutree(x, k = 20)
```

## Raw data
```{r raw-data, message=FALSE, warning=FALSE}
ggplot(data, aes(x=fi, y=logk, group=ID)) + 
  geom_line(aes(color=logP_ACD)) + 
  facet_wrap(~mm_group, ncol=2) +
  labs(x = "\u03C6", y = expression(log~k[obs])) + 
  theme_gray(base_size = 14) + theme(legend.position="none") 


temp_tri<-lower_tri_df%>%arrange(desc(similarity))%>%filter(row!=col, similarity>0.8)

i=349;
data %>% 
  filter(ID %in% c(temp_tri$row[i],temp_tri$col[i])) %>%
  ggplot(aes(x=fi, y=logk, group=ID)) + 
  geom_line(aes(color=logP_ACD)) + 
  labs(title = paste(analytes_names$Analyte[temp_tri$row[i]], "\n", analytes_names$Analyte[temp_tri$col[i]], temp_tri$similarity[i]), x = "\u03C6", y = expression(log~k[obs])) + 
  theme_gray(base_size = 10) + theme(legend.position="none")

```
## pH changes

The pH value of the mobile phase was verified experimentally for the purpose of this work. It equaled 2.66 with a standard deviation of 0.19 for the range of acetonitrile contents from 5 to 95%.

```{r pH-plot, message=FALSE, warning=FALSE}
ggplot(data=data_pH, aes(x=fi, y=pH)) + labs(x = "\u03C6", y = "pH") + 
  geom_point() + geom_hline(yintercept=mean(data_pH$pH), color = "red") +
  geom_hline(yintercept=mean(data_pH$pH)-sd(data_pH$pH), linetype="dashed", color = "red") +
  geom_hline(yintercept=mean(data_pH$pH)+sd(data_pH$pH), linetype="dashed", color = "red") + 
  ylim(c(2.0,3.5))
```

## logP and Moleculr mass distribution

The values of molecular mass MM were added to the dataset. They were calculated using [ACD/Labs program](www.acdlabs.com) based on the provided structures of analytes. The MM ranged from 73.09 to 656.8.

```{r hist-MW-logP,message=FALSE, warning=FALSE}

df <- data %>% distinct(ID, .keep_all = TRUE) 

p1<-ggplot(data=df)+
  geom_histogram(aes(x=MW_ACD))+
  xlab("molecular mass")+
  ylab("count")

p2<-ggplot(data=df)+
  geom_histogram(aes(x=logP_ACD))+
  xlab("logP")+
  ylab("count")

p1+p2

```

## Functional groups

The functional groups present in the analyzed chemical compounds are presented below, along with their frequencies

```{r functional-group-summary, message=FALSE, warning=FALSE}

sumdata=data.frame(value=apply(functional_groups,2,sum))

sumdata$key=functional_groups_names[,2]
sumdata <- sumdata[order(sumdata$value),]
sumdata$split <- rep(c(1,2),each=49)

layout(c(1,2), widths=c(1,3))

p1 <- ggplot(data=sumdata[which(sumdata$split==1),], aes(x=reorder(key, +value), y=value, fill=key)) +
  geom_bar(fill="gray", stat="identity") + 
  theme(legend.position = "none",
        axis.title.x=element_blank(),
        axis.title.y=element_blank()) + 
  coord_flip()+
  scale_y_continuous(breaks=c(0,5,10))

p2 <- ggplot(data=sumdata[which(sumdata$split==2),], aes(x=reorder(key, +value), y=value, fill=key)) +
  geom_bar(fill="gray", stat="identity") + 
  theme(legend.position = "none",
        axis.title.x=element_blank(),
        axis.title.y=element_blank()) + 
  coord_flip() + scale_y_continuous(trans='log10',breaks=c(1,10,100,1000))

# Combine the plots with a custom layout
p1 + p2 + plot_layout(design = "1222")
```

## Initial estimates
```{r initial-estimates}
initial_param <- matrix(NA,nAnalytes,3)

for(i in 1:nAnalytes){
  if(length(data$fi[data$ID==i])==1){
    initial_param[i,2] <- polyfit(-16*data$fi[data$ID==i]/(1+2*data$fi[data$ID==i]), data$logk[data$ID==i],0)
    initial_param[i,1] <- -16
  }else{
    initial_param[i,1:2] <- polyfit(data$fi[data$ID==i]/(1+2*data$fi[data$ID==i]), data$logk[data$ID==i],1)
  }
}

initial_param[,3] <- rep(2,nAnalytes)

init_aprox <-  data.frame(logkw = initial_param[,2])
init_aprox$S2 <- rep(2,nAnalytes)
init_aprox$S1 <- -initial_param[,1]/(1+2)
init_aprox$chargesB0 <-chargesB[,2]
init_aprox$chargesA0 <-chargesA0

init_aprox$MW <-MW
init_aprox$logPobs <- logPobs
init_aprox$cutavg <- cut_avg
```

### Plots
```{r initial-estimates-plot}
init_aprox %>%
  ggplot(aes(x=logkw,y=S1,color=factor(chargesB0+chargesA0)))+
  geom_point()+
  labs(color="charges")

init_aprox %>%
  ggplot(aes(x=logPobs,y=logkw,color=factor(chargesB0+chargesA0)))+
  geom_point()+
  labs(color="charges")+facet_wrap(.~factor(cutavg))
```

# Session info
```{r}
sessionInfo()
```