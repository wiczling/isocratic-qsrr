---
title: "QSRR revisited. Hierarchical models"
author:
  - name: "Paweł Wiczling*"
    affiliations:
      - name: "Department of Biopharmaceutics and Pharmacodynamics, Medical University of Gdańsk, Gen. J. Hallera 107, 80-416 Gdańsk, Poland"
date: "`r format(Sys.Date())`"
format:
  html:
    theme: cosmo
    toc: true
    code-fold: true  
    code-tools: true
    fig-width: 7
    fig-height: 7
knitr:
  opts_chunk: 
    dev: "ragg_png"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=FALSE, message=FALSE, error=FALSE, warning=FALSE, comment=NA, out.width='95%')
```

# Introductions

...

# Setup
```{r message=FALSE}
library(ggplot2)
library(gridExtra)
library(patchwork)
library(tidyr)
library(dplyr)
library(GGally)
library(reshape2)
library(pracma)
library(here)
library(magick)
library(reticulate)
library(kableExtra)
#remotes::install_github("metrumresearchgroup/mrgmisc")

set.seed(10271998) ## not required but assures repeatable results

source("helper-functions.R")
```

```{r settings}
data_deliv_dir = here::here("data","deliv")
data_derived_dir = here::here("data","derived")
if(!file.exists(data_deliv_dir)) dir.create(data_deliv_dir, recursive = T)
if(!file.exists(data_derived_dir)) dir.create(data_derived_dir, recursive = T)

figures_eda_dir <- here::here("deliv","figures", "eda")
tables_eda_dir <- here::here("deliv","tables", "eda")
if(!file.exists(figures_eda_dir)) dir.create(figures_eda_dir, recursive = T)
if(!file.exists(tables_eda_dir)) dir.create(tables_eda_dir, recursive = T)

model_dir <- here::here("model","stan")  
figures_dir <- here::here("deliv","figures", "stan")
tables_dir <- here::here("deliv","tables", "stan")
if(!file.exists(figures_dir)) dir.create(figures_dir, recursive = T)
if(!file.exists(model_dir)) dir.create(model_dir, recursive = T)
if(!file.exists(tables_dir)) dir.create(tables_dir, recursive = T)
```

# EDA

We used a publicly available [dataset](www.retentionprediction.org/hplc/database/) that comprises the measurements of RP-HPLC retention times collected for 1026 analytes. The retention times were measured under isocratic conditions on Eclipse Plus C18 (Agilent) stationary phase with 3.5 μm particles. The experiments were conducted using a mixture of two solvents: solvent A, which was made of 0.1% formic acid in water, and solvent B, which was made of 0.1% formic acid in acetonitrile. The column temperature was set at 35\^{\circ}C. The data were collected by Boswell et al. and were used to create a method to predict retention time by Back-Calculating the Gradient.

## Load data
```{r load-data, message=FALSE, warning=FALSE}
# load data
data <- read.csv(here(data_deliv_dir, "database_logk_1026.csv"), header = TRUE)
analytes_names  <- read.csv(here(data_deliv_dir,"database_logk_1026_analyte_names.csv"), header = TRUE)
smiles <- read.csv(here(data_deliv_dir,"smiles1026.smi"), sep = "\t", header = FALSE)
functional_groups = read.csv(here(data_deliv_dir, 'checkmol_functional_groups.csv'))
functional_groups_names = read.csv(here(data_deliv_dir,'checkmol_functional_group_names.csv'))
data_ACD = read.csv(here(data_deliv_dir,'ACD_pKas.csv'))
data_pH <- read.csv(here(data_deliv_dir,"pH.csv"),header = TRUE)
lower_tri_df <-read.csv(here(data_deliv_dir,"similarity_ltri_rcdk.csv"))
#similarity_matrix <- make_similarity_matrix_fun(lower_tri_df)
smiles<-smiles %>% rename(ID=V2,smiles=V1) %>% select(ID,smiles)
```

# Python

```{r load-conda-environment}
use_condaenv("rdkit-env", conda = "C:/Users/GUMed/anaconda3/Scripts/conda.exe", required = TRUE)
```


```{r}
temp_tri<-lower_tri_df %>% arrange(row,col)

df_temp = data %>% distinct(ID, .keep_all = TRUE)
temp_tri$dMW = abs(df_temp$MW_ACD[temp_tri$row]- df_temp$MW_ACD[temp_tri$col])

temp_tri<-temp_tri %>% 
  filter(row!=col) %>%
  group_by(row) %>%
  slice_max(similarity, n = 1, with_ties = TRUE) %>%
  slice_min(dMW, n = 1, with_ties = TRUE) %>%
  ungroup() %>%
  arrange(desc(similarity)) %>% 
  filter(similarity>0.5) 

k2 = df_temp$MW_ACD[temp_tri$row]> df_temp$MW_ACD[temp_tri$col]
temp_tri$xrow = temp_tri$row
temp_tri$xcol = temp_tri$col

temp_tri$xrow[k2] = temp_tri$col[k2]
temp_tri$xcol[k2] = temp_tri$row[k2]
```

# Maximum Common Substructure

```{r mcs, eval=FALSE}

# Import RDKit modules
Chem <- import("rdkit.Chem")
AllChem <- import("rdkit.Chem.AllChem")
Draw <- import("rdkit.Chem.Draw")
rdFMCS <- import("rdkit.Chem.rdFMCS")
rdmolops <- import("rdkit.Chem.rdmolops")
# Settings 
# Create MCS parameters
mcs_params <- rdFMCS$MCSParameters()
mcs_params$AtomCompareParameters$MatchValences <- TRUE 
mcs_params$AtomCompareParameters$RingMatchesRingOnly <- TRUE  
mcs_params$AtomCompareParameters$Compare <- rdFMCS$AtomCompare$CompareElements
mcs_params$BondCompareParameters$CompleteRingsOnly <- TRUE 
mcs_params$BondCompareParameters$Compare <- rdFMCS$BondCompare$CompareOrder
mcs_params$MaximizeBonds <- TRUE
mcs_params$Timeout <- 20L           
#mcs_params$Verbose <- FALSE
mcs_params$Threshold <- 0.5  

extract_common_fragments <- function(mol, match_atoms) {
  
editable_mol <- Chem$RWMol(mol)
mcs_atom_indices <- as.integer(match_atoms)

# Remove all atoms not in MCS (do it in reverse to preserve indices)
all_indices <- 0:(mol$GetNumAtoms() - 1)
atoms_to_remove <- setdiff(all_indices, mcs_atom_indices)

for (idx in rev(atoms_to_remove)) {
  editable_mol$RemoveAtom(as.integer(idx))
}

# Get final molecule
common_mol <- editable_mol

num_atoms <- common_mol$GetNumAtoms()
 for (i in seq(0, num_atoms - 1)) {
     atom <- common_mol$GetAtomWithIdx(i)
     if (!atom$IsInRing() && atom$GetIsAromatic()) {
         atom$SetIsAromatic(FALSE)
     }
 }

 res <- try({
     Chem$SanitizeMol(common_mol)
    }, 
    silent = TRUE)
  
  if (inherits(res, "try-error")) {
  common_smiles <- Chem$MolToSmiles(common_mol)
  common_smiles = paste0("Err:",common_smiles)
  } else {
  Chem$SanitizeMol(common_mol)
  common_smiles <- Chem$MolToSmiles(common_mol)
  }

return(common_smiles)
}

extract_attachemnt_string <- function(mol, match_atoms) {
  
  all_atoms <- seq_len(mol$GetNumAtoms()) - 1L
  diff_atoms <- setdiff(all_atoms, match_atoms)
  
attachment_strings <- c()
for (atom_idx in match_atoms) {
  atom <- mol$GetAtomWithIdx(atom_idx)
  atom_symbol <- atom$GetSymbol()

  for (bond in atom$GetBonds()) {
    nbr_idx <- bond$GetOtherAtomIdx(atom_idx)
    if (!(nbr_idx %in% match_atoms)) {
      nbr_atom <- mol$GetAtomWithIdx(nbr_idx)
      nbr_symbol <- nbr_atom$GetSymbol()
      bond_type <- as.character(bond$GetBondType())

      attachment_strings <- c(
        attachment_strings,
        sprintf("%d:%s %d:%s %s",
                atom_idx, atom_symbol,
                nbr_idx, nbr_symbol,
                bond_type)
      )
    }
  }
}
return(paste(attachment_strings, collapse = "."))
}

extract_diff_fragments <- function(mol, match_atoms) {
  
  all_atoms <- seq_len(mol$GetNumAtoms()) - 1L
  diff_atoms <- setdiff(all_atoms, match_atoms)
  
  if (length(diff_atoms) == 0) return("")
  
  rw_mol <- Chem$RWMol(mol)
  
  # Set atoms to remove (in reverse order to preserve indices)
  for (idx in sort(unlist(match_atoms), decreasing = TRUE)) {
    rw_mol$RemoveAtom(idx)
  }

  res <- try({
    mol_frags <- rdmolops$GetMolFrags(rw_mol, asMols = TRUE)
    }, 
    silent = TRUE)
  
  if (inherits(res, "try-error")) {
  mol_frags <- rdmolops$GetMolFrags(rw_mol, asMols = TRUE, sanitizeFrags = FALSE)
  } else {
  mol_frags <- rdmolops$GetMolFrags(rw_mol, asMols = TRUE)
  }

  frag_smiles <- sapply(mol_frags, function(frag) as.character(Chem$MolToSmiles(frag)))
  return(paste(frag_smiles, collapse = "."))
}

compare_smiles_pair <- function(smiles1, smiles2, .mcs_params=mcs_params) {
  
  mol1 <- Chem$MolFromSmiles(smiles1)
  mol2 <- Chem$MolFromSmiles(smiles2)

  if (is.null(mol1) || is.null(mol2)) {
    return(data.frame(
    smile1 = smiles1,
    smile2 = smiles2,
    common = NA,
    to_remove = NA,
    to_remove_str = NA,
    to_add = NA,
    to_add_str = NA,
    structure = "<em>Invalid SMILES</em>"
    ))
  }

 mcs_result <- rdFMCS$FindMCS(list(mol1, mol2), parameters = mcs_params)
 smarts <- mcs_result$smartsString
 common_mol <- Chem$MolFromSmarts(smarts)

  # Get atom matches for highlighting
  match1 <- mol1$GetSubstructMatch(common_mol)
  match2 <- mol2$GetSubstructMatch(common_mol)

  # Compute unmatched SMILES
  to_remove <- extract_diff_fragments(mol1, match1)
  to_add <- extract_diff_fragments(mol2, match2)

  to_remove_str <- extract_attachemnt_string(mol1, match1)
  to_add_str <- extract_attachemnt_string(mol2, match2)
  
  common_smile <- extract_common_fragments(mol1, match1)
  
  # Generate 2D coordinates
  AllChem$Compute2DCoords(mol1)
  AllChem$Compute2DCoords(mol2)
    
  # Draw image
  img <- Draw$MolsToGridImage(
    list(mol1, mol2),
    highlightAtomLists = list(match1, match2),
    subImgSize = tuple(300L, 300L),
    legends = list("Mol 1", "Mol 2")
  )

  # Save to temp file and encode as base64 HTML img tag
  img_file <- tempfile(fileext = ".png")
  img$save(img_file)
  img_base64 <- base64enc::dataURI(file = img_file, mime = "image/png")

  
  gc()
  py_run_string("import gc; gc.collect()")
 # img_magick <- image_read(img_file)
 # print(img_magick)  # Displays in RStudio viewer or default graphics device

  # Return data frame row
  data.frame(
    smile1 = smiles1,
    smile2 = smiles2,
    common = common_smile,
    to_remove = to_remove,
    to_remove_str= to_remove_str,
    to_add = to_add,
    to_add_str=to_add_str,
    structure = sprintf('<img src="%s" style="width:600px; height:auto;"/>', img_base64), 
    stringsAsFactors = FALSE)
}

# Extract the vectors
rows <- smiles$smiles[temp_tri$row]
cols <- smiles$smiles[temp_tri$col]


comparison_table <- purrr::map2_df(rows, cols, compare_smiles_pair,
                                   .progress = list(
  type = "iterator", 
  format = "Calculating {cli::pb_bar} {cli::pb_percent} {cli::pb_current}/{cli::pb_total}",
  clear = FALSE))

write.csv(comparison_table, file = here(data_deliv_dir,"comparison_table.csv"), row.names = FALSE)
```

```{r print table}
comparison_table = read.csv(file = here(data_deliv_dir,"comparison_table.csv"), header = TRUE)
comparison_table$similarity = round(temp_tri$similarity,2)
comparison_table$id1 = temp_tri$row
comparison_table$id2 = temp_tri$col

comparison_table %>%
  select("id1", "id2", "similarity", "structure") %>%
  kbl(escape = FALSE, format = "html", align = "l") %>%
  kable_styling(full_width = FALSE, position = "center", bootstrap_options = c("striped", "hover", "condensed"))

comparison_table %>%
  select("id1", "id2", "similarity", "common", "to_remove","to_remove_str","to_add", "to_add_str") %>%
  kbl(escape = FALSE, format = "html", align = "l") %>%
  kable_styling(full_width = FALSE, position = "center", bootstrap_options = c("striped", "hover", "condensed"))
```

```{r visualise}
require(visNetwork, quietly = TRUE)
# minimal example
nodes <- data.frame(id = unique(c(temp_tri$row,temp_tri$col)),
                    label = paste(unique(c(temp_tri$row,temp_tri$col))))

edges <- data.frame(from = temp_tri$row, to = temp_tri$col)
visNetwork(nodes, edges, width = "100%") %>% 
    visEdges(arrows ="to") 
```

# Session info

```{r}
sessionInfo()
```